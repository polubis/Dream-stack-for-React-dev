---
lang: pl
title: RÃ³Å¼nica pomiÄ™dzy typami a interfejsami w TypeScript
description: Zrozumiemy gÅ‚Ã³wne rÃ³Å¼nie pomiÄ™dzy typami a interfejsami oraz sprawdzimy jaki impakt mogÄ… mieÄ‡ na czas kompilacji.
---

<Prelude label="SkÄ…d te zamieszanie">
  <M>
    RÃ³Å¼nego rodzaju skrÃ³ty myÅ›lowe spodowaÅ‚y, Å¼e w <B>TypeScript</B>, typ oraz
    interfejs sÄ… uÅ¼ywane nagminnie, i w zÅ‚ym kontekÅ›cie. Czasami sÅ‚yszy siÄ™ od
    deweloperÃ³w:{' '}
  </M>
  <L>
    <Li>"TworzÄ™ modele w innym pliku",</Li>
    <Li>"Zawsze dodajÄ™ interfejsy do odpowiedzi API",</Li>
    <Li>"Zwracam typy dla kaÅ¼dej funkcji",</Li>
    <Li>"Moje deklaracje oraz definicje sÄ… zawsze w oddzielnym pliku".</Li>
  </L>
  <M>
    No wÅ‚aÅ›nie... KaÅ¼da z wypowiedzi dotyczy tego samego. W kontekÅ›cie{' '}
    <B>TypeScript</B> jeÅ¼eli masz na myÅ›li tworzenie struktur, ksztaÅ‚tÃ³w,
    kontraktÃ³w, ktÃ³re majÄ… opisaÄ‡/okreÅ›liÄ‡ twÃ³j kod, powinieneÅ› uÅ¼ywaÄ‡ zawsze
    stwierdzenia - <B>definicje/deklaracje typÃ³w</B>.
  </M>
  <Hint hasBg>
    Interfejs to teÅ¼ typ, tylko taki, ktÃ³ry okreÅ›la ksztaÅ‚t/kontrakt dla
    obiektÃ³w.
  </Hint>
  <M>
    WÅ‚aÅ›nie z takich powodÃ³w ciÄ™Å¼ko jest zrozumieÄ‡ rÃ³Å¼nice. MoÅ¼e siÄ™ ona rÃ³wnieÅ¼
    Å‚atwo zacieraÄ‡, bo jeÅ¼eli w kontekÅ›cie aplikacji uÅ¼ywamy gÅ‚Ã³wnie{' '}
    <B>interfejsÃ³w</B>, a w <B>React</B> to juÅ¼ praktycznie zawsze (opisywanie
    odpowiedzi <B>API</B>, opisywanie <B>propsÃ³w</B> oraz opisywanie{' '}
    <B>stanu</B>), to moÅ¼na wyciÄ…gnÄ…Ä‡ bÅ‚Ä™dny wniosek.{' '}
  </M>
  <M>
    ZaczeÅ‚y pojawiaÄ‡ siÄ™ pytania: "Powinienem uÅ¼ywaÄ‡ interfejsÃ³w czy typÃ³w?".
    Jest to pytanie zrozumiaÅ‚e, ale brakuje tu szerszego kontekstu. Powinno
    brzmieÄ‡: "Do czego wykorzystuje siÄ™ typy, a do czego interfejsy, i jakie sÄ…
    rÃ³Å¼nice pomiÄ™dzy nimi?". No i teraz moÅ¼emy zaczÄ…Ä‡ artykuÅ‚ â˜œ(ï¾Ÿãƒ®ï¾Ÿâ˜œ).
  </M>
</Prelude>

<Prelude label="Interfejsy to obiekty, a typy to?">
  <M>
    SpÃ³jrz na poniÅ¼szy kod, w ktÃ³rym prÃ³bujemy wykorzystaÄ‡ <B>interface</B> oraz{' '}
    <B>type</B> do stworzenia rÃ³Å¼nych deklaracji.
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    description="Interfejsy mogÄ… byÄ‡ wykorzystane tylko do definicji obiektÃ³w"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/mozliwosci-interfejsow.ts"
    linesCount={19}
  />
  <M>
    W takim razie dlaczego moÅ¼na opisaÄ‡ interfejsem rÃ³wnieÅ¼ <B>funkcjÄ™</B> oraz{' '}
    <B>tablicÄ™</B>? A dzieje siÄ™ tak dlatego, Å¼e to rÃ³wnieÅ¼ obiekty. Tak po
    prostu jest w <B>JavaScript</B> i byÅ‚o by dziwne gdyby <B>TypeScript</B>{' '}
    pominÄ…Å‚ ten istotny szczegÃ³Å‚.
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    description="Za pomocÄ… typÃ³w moÅ¼na opisaÄ‡ wszystko"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/mozliwosci-typow.ts"
    linesCount={28}
  />
  <M>
    Interfejsy sÅ‚uÅ¼Ä… do opisywania tylko i wyÅ‚Ä…cznie obiektÃ³w, a typami moÅ¼emy
    opisaÄ‡ dosÅ‚ownie wszystko, kaÅ¼dÄ… strukturÄ™ danych (string, boolean, object,
    ...etc). RÃ³wnieÅ¼ prawdziwe jest stwierdzenie, Å¼e sÅ‚owo kluczowe{' '}
    <B>interface</B> sÅ‚uÅ¼y do opisywania zmiennych <B>referencyjnych</B> - czyli
    obiektÃ³w.
  </M>
</Prelude>

<Section>
  <XL>Dlaczego interfejsy opisujÄ… akurat obiekty?</XL>
  <M>
    Koncept <B>interfejsÃ³w</B> wywodzi siÄ™ z programowania obiektowego. Jest to
    ksztaÅ‚t jaki obiekt powinien przyjÄ…Ä‡. Idealnym przykÅ‚adem do
    wytÅ‚umaczenia tego konceptu bÄ™dzie pilot do telewizora. <B>Interfejsem</B> w
    tym kontekÅ›cie bÄ™dÄ… przyciski i plastikowa obudowa. Wiele firm moÅ¼e zrobiÄ‡
    wiele pilotÃ³w. WaÅ¼ne jest tylko i wyÅ‚Ä…cznie to, aby funkcje przyciskÃ³w
    dziaÅ‚aÅ‚y tak samo - przeÅ‚Ä…czaÅ‚y kanaÅ‚y, zwiÄ™kszaÅ‚y gÅ‚oÅ›noÅ›Ä‡, ...etc. RÃ³Å¼nica pomiÄ™dzy nimi to <B>implementacja</B> - kaÅ¼da firma moÅ¼e zrobiÄ‡ pilot
    inaczej, ale dziaÅ‚aÄ‡ musi tak samo. Zobaczmy ten przykÅ‚ad w kodzie:{' '}
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    description="Interefejsy moÅ¼emy wykorzystaÄ‡ rÃ³wnieÅ¼ w kontekÅ›cie klas"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/przyklad-z-pilotem.ts"
    linesCount={20}
  />
  <M>PowyÅ¼ej za pomocÄ… interfejsÃ³w zdefiniowaliÅ›my ksztaÅ‚ dla dwÃ³ch klas. Teraz dopÃ³ki jako deweloperzy nie wywiÄ…Å¼emy siÄ™ z kontraktu (interfejs), <B>TypeScript</B> bÄ™dzie nam jÄ™czaÅ‚. </M>
</Section>

<Section>
  <XL>Niejawne scalanie deklaracji w interfejsach</XL>
    <M>
    DefiniujÄ…c wiÄ™cej niÅ¼ jeden interfejs, <B>TypeScript</B> scali deklaracje do
    jednej (deklaracje muszÄ… mieÄ‡ taka samÄ… nazwÄ™ i znajdowaÄ‡ siÄ™ w tym samym pliku). 
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/scalanie-deklaracji.ts"
    linesCount={14}
  />
    <M>
    Bardzo istotne jest to, Å¼e <B>interfejsy</B> zdefiniowane w oddzielnych
    plikach nie zostanÄ… <B>scalone</B> w przypadku takiej samej nazwy (nawet
    jeÅ¼eli wszystkie sÄ… exportowane).
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/export-interfejsow-nie-wplywa-na-scalanie.ts"
    linesCount={13}
  />
    <M>
    No dobra, ale dlaczego twÃ³rcy wprowadzili taki mechanizm? Jest to po prostu
    dla naszej "wygody". W rÃ³Å¼nych technologiach wystÄ™pujÄ… mechanizmy niejawne,
    ktÃ³re redukujÄ… potrzebe pisania przez nas kodu - musimy tylko wiedzieÄ‡ jak
    coÅ› dziaÅ‚a - analogicznym przykÅ‚adem moÅ¼e byÄ‡{' '}
    <B>niejawna konwersja typÃ³w</B> w <B>JavaScript</B>. W tym jednak przypadku,
    mechanizm ten czasami jest bardziej problematyczny niÅ¼ pomocny ğŸ’¢. 
  </M>
  <M>Dodatkowo warto zaznaczyÄ‡, Å¼e mechanizm ten moÅ¼e byÄ‡ bardzo uÅ¼yteczny jeÅ¼eli korzystamy z biblioteki, ktÃ³ra ma Åºle zdefiniowane typy. DziÄ™ki temu mechanizmowi, moÅ¼emy dodaÄ‡ wÅ‚asne pola do interfejsÃ³w bÄ…dÅº nadpisaÄ‡ bÅ‚Ä™dne deklaracje. </M>
<Code
mode="dynamic"
lang="tsx"
description="NadpisaliÅ›my definicje typÃ³w dla biblioteki 'styled-components' dla caÅ‚ego projektu"
src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/niejawne-scalanie-w-deklaracjach.ts"
linesCount={7}
/>
</Section>

<Section>
  <XL>Jawne scalanie deklaracji w interfejsach</XL>

  <M>
    Aby zrobiÄ‡ to <B>jawnie</B>, wystarczy uÅ¼yÄ‡ sÅ‚owa <B>extends</B> (jeÅ¼eli
    interfejs ma innÄ… nazwÄ™ bÄ…dÅº jest importowany z innego pliku).{' '}
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/scalanie-deklaracji-jawne.ts"
    linesCount={15}
  />
</Section>

<Section>
  <XL>Scalanie deklaracji dla typÃ³w</XL>
  <M>
    Niejawne scalanie deklaracji dla typÃ³w nie istnieje.
    Jest tak dlatego, Å¼e <B>typy</B> muszÄ… mieÄ‡ unikalnÄ… nazwÄ™ dla danego{' '}
    <B>scope</B>. Czyli kod, ktÃ³ry widzicie poniÅ¼ej nie zadziaÅ‚a z oczywistych
    powodÃ³w, bo nazwy sÄ… takie same:{' '}
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    description="Typy muszÄ… mieÄ‡ unikalnÄ… nazwÄ™"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/typy-sa-unikalne.ts"
    linesCount={12}
  />
  <M>
    Jednak definicje typÃ³w moÅ¼emy scalaÄ‡ <B>jawnie</B> korzystajÄ…c z operatora{' '}
    <B>&</B> - <B>operator logicznego AND</B> czy nazywany rÃ³wnieÅ¼ <B>operatorem scalania typÃ³w</B>.
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    description="Musimy jedynie pamiÄ™taÄ‡, Å¼e nazwy nie mogÄ… siÄ™ duplikowaÄ‡"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/jawne-scalanie-typow.ts"
    linesCount={12}
  />
</Section>

<Section>
  <XL>Scalanie wielu deklaracji dla interfejsÃ³w oraz typÃ³w</XL>
  <M>
    JeÅ¼eli chcemy scaliÄ‡ wiele deklaracji, to moÅ¼emy zrobiÄ‡ to w nastÄ™pujÄ…cy
    sposÃ³b dla <B>interfejsÃ³w</B> i <B>typÃ³w</B>.
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/scalanie-wielu-deklaracji.ts"
    linesCount={11}
  />
</Section>

<Section>
  <XL>Scalanie interfejsÃ³w z typami i odwrotnie</XL>
  <M>
    JeÅ¼eli mamy interfejs o nazwie <B>A</B> i typ o takiej same nazwie, to ich
    scalanie nie bedzie moÅ¼liwe.
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/interfejs-i-typ-w-jednym-pliku.ts"
    linesCount={25}
  />
  <M>RownieÅ¼ w odwrotnÄ… stronÄ™ jest to moÅ¼liwe: </M>
  <Code
mode="dynamic"
lang="tsx"
src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/interfejsy-dziedzicza-typy.ts"
linesCount={3}
/>
</Section>

<Section>
  <XL>Interfejsy majÄ… lepszy performance?</XL>
  <M>Jak juÅ¼ wiemy, obiekty moÅ¼emy opisywaÄ‡ za pomocÄ… <B>interfejsÃ³w</B> oraz <B>typÃ³w</B>. Dlaczego w takim razie nie byÄ‡ spÃ³jnym i nie wykorzystywaÄ‡ zawsze sÅ‚owa <B>type</B> do wszystkiego? Raz, Å¼e definicja za pomocÄ… <B>type</B> wyglÄ…da zwiÄ™Åºlej no i jest bardziej "fancy". Jest kilka powodÃ³w...</M>
  <M>Definiowanie obiektÃ³w za pomocÄ… interfejsÃ³w pozytywnie wpÅ‚ywa na czas kompilacji oraz <B>type checking</B> podczas pracy w <B>IDE</B>. ZwÅ‚aszcza gdy jest ich bardzo duÅ¼o i chcemy je ze sobÄ… scalaÄ‡. WyobraÅº sobie ogromny projekt, w ktÃ³rym po wcisniÄ™ciu przycisku <B>save</B>, czekasz kilka sekund na ponownÄ… kompilacje lub twÃ³j czas budowania aplikacji znacznie siÄ™ wydÅ‚uÅ¼a. </M>
<Code
mode="dynamic"
lang="tsx"
src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/types-only.ts"
linesCount={13}
/>
<Code
mode="dynamic"
lang="tsx"
src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/interfaces-only.ts"
linesCount={13}
/>
<M>Zapis za pomocÄ… interfejsÃ³w ma byÄ‡ lÅ¼ejszy dla kompilatora. Niby dlatego, Å¼e obiekty zadeklarowane za pomocÄ… <B>type</B> sÄ… scalane rekurencyjnie, natomiast dla interfejsÃ³w tworzony jest pojedyÅ„czy typ, w ktÃ³rym Å‚atwo wykryÄ‡ konflikty wÅ‚aÅ›ciwoÅ›ci i je rozwiÄ…zaÄ‡.  </M>
<Hint hasBg>WiÄ™cej na ten temat pod <A outside href="https://github.com/microsoft/TypeScript/wiki/Performance">tym repozytorium</A>.</Hint>
<M>No dobra lepszy, ale czy na pewno i jeÅ¼eli tak to o ile? ZrÃ³bmy maÅ‚y eksperyment :P. Pod repozytorium <A outside href="https://github.com/polubis/Dream-stack-for-React-dev/tree/develop">Dream stack for React developer</A> w momencie pisania tego artykuÅ‚u znajduje siÄ™ prawie 500 interfejsÃ³w. Wszystkie je zamienimy na <B>type</B> i sprawdzimy czy coÅ› siÄ™ zmieniÅ‚o w czasie kompilacji, budowania oraz ogÃ³lnym dziaÅ‚aniem wtyczek 
w <B>IDE</B>. </M>
<M>Najpierw pomiar dla <B>interfejsÃ³w</B>. Z racji tego, iÅ¼ korzystamy w wyÅ¼ej wymienionym repozytorium z <B>NX</B> do zarzÄ…dzania <B>monorepo</B>, nasze polecenie do budowania bÄ™dzie wyglÄ…daÅ‚o w ten sposÃ³b: </M>
<M><B>npx nx run-many --target=build --skip-nx-cache --all</B></M>
<M>OczywiÅ›cie pozbywamy siÄ™ <B>cache</B> flagÄ… <B>--skip-nx-cache</B> i za kaÅ¼dym nastÄ™pnym testem bÄ™dziemy czyÅ›ciÄ‡ katalog z <B>buildem</B>. Czekamy chwilkÄ™ i wyniki sÄ… nastÄ™pujÄ…ce: </M>
<Image
rolled
  src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/b-refactor.jpg"
  description="Przed zmianÄ…"
/>
<M>Teraz dodajemy nastÄ™pujÄ…cy <B>commit</B> z podmianÄ… <B>interface</B> na <B>type</B>. </M>
<Image
rolled
  src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/showcase-refactor.gif"
/>
<M>Czekamy chwilkÄ™ i mamy wynik.</M>
<Image
rolled
  src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/a-refactor.jpg"
  description="Po zmianie"
/>
<M>No dobra, ale czy nasz pomiar jest prawidÅ‚owy? PrzecieÅ¼ czas <B>buildu</B> zaleÅ¼y od wielu czynnikÃ³w, chociaÅ¼by od tego jak bardzo obciaÅ¼ony jest aktualnie mÃ³j komputer. WyÅ‚Ä…czyÅ‚em wszystko co siÄ™ tylko daÅ‚o i zaczÄ…Å‚em kilka ponownych pomiarÃ³w, a wyniki byÅ‚y bardzo zbliÅ¼one - rÃ³Å¼niÅ‚y siÄ™ kilkoma sekundami i to czasami na korzyÅ›Ä‡ <B>typÃ³w</B>. </M>
<M>StwierdziÅ‚em, Å¼e muszÄ™ sprawdziÄ‡ jeszcze jednÄ… rzecz, ile trwa tylko i wyÅ‚Ä…cznie kompilacja. Zatem, dodaÅ‚em do pliku <B>tsconfig</B> nastÄ™pujÄ…cÄ… wÅ‚aÅ›ciwoÅ›Ä‡: <B>extendedDiagnostics: true</B>, ktÃ³ra powoduje logowanie czasu jaki kompilator poÅ›wiÄ™ciÅ‚ na kompilacje. </M>
<Code
mode="dynamic"
lang="json"
added={[[5,5]]}
src="https://raw.githubusercontent.com/polubis/Dream-stack-for-React-dev/article/Types-vs-interfaces-in-TypeScript-fully-explained/system/pl/extended-diagnostics.json"
linesCount={12}
/>

<M>ZaczÄ…Å‚em kompilowaÄ‡ poszczegÃ³lne projekty oddzielnie za pomocÄ… polecenia <B>tsc -p tsconfig.app.json --noEmit</B>, aby uruchomiÄ‡ <B>type-checking</B> i nie tworzyÄ‡ plikÃ³w z deklaracjami (flaga <B>--noEmit</B>). Nie byÅ‚o Å¼adnej wiÄ™kszej rÃ³Å¼nicy... No dobra, to zostaÅ‚o nam tylko <B>IDE</B> i <B>type-checking</B> w czasie rzeczywistym. Ja uÅ¼ywam <B>VS code</B> - popracowaÅ‚em nad tym samym <B>feature</B> 30 minut na dwÃ³ch branchach i nie zauwaÅ¼yÅ‚em Å¼adnej rÃ³Å¼nicy - moÅ¼e na wolniejszym komputerze mogÅ‚aby wystÄ…piÄ‡, ale szczerze w to wÄ…tpie. </M>
<M>Wnioski nasuwajÄ… siÄ™ same - nie ma to wiÄ™kszego znaczenia pod kÄ…tem <B>budowania</B> oraz <B>kompilacji</B>. JeÅ¼eli masz problem z wyÅ¼ej wymienionymi, to najprawdopodobniej problem jest gdzie indziej. MoÅ¼e jest to coÅ› z zagadnieÅ„ w <A outside href="https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections">tym artykule</A>.</M>
<M>JeÅ¼eli chcesz sam sprawdziÄ‡ jak to wyglÄ…da u Ciebie, to poniÅ¼ej masz branche <B>przed/po</B>.</M>
<Hint hasBg><A outside href="https://github.com/polubis/Dream-stack-for-React-dev/tree/articles/Benchmarking-interfaces-vs-types-before">Branch przed zmianami</A>.</Hint>
<Hint hasBg><A outside href="https://github.com/polubis/Dream-stack-for-React-dev/tree/articles/Benchmarking-interfaces-vs-types-after">Branch po zmianach</A>.</Hint>
</Section>
